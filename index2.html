<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>AR Experience</title>
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.0/dist/mindar-image-aframe.prod.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      position: fixed;
      background-color: transparent;
    }

    #loading-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
      height: 90%;
      max-height: 800px;
      background: url('assets/mainbackground.png') no-repeat center center;
      background-size: contain;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .play-button {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      display: none;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 50%;
    }

    .play-button::before {
      content: '';
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 20px 0 20px 40px;
      border-color: transparent transparent transparent rgba(255, 255, 255, 0.9);
      transform: translateX(5px);
      position: absolute;
    }

    #loading-progress {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 16px;
      border-radius: 20px;
      font-family: Arial, sans-serif;
      z-index: 1000;
    }

    #ar-scene {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    #ar-scene.ready {
      opacity: 1;
    }

    a-scene {
      background-color: transparent !important;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="loading-screen"></div>
  <div id="loading-progress">Loading...</div>
  <div id="ar-scene">
    <a-scene
      mindar-image="imageTargetSrc: ./targets19.mind; filterMinCF:0.0001; filterBeta:0.001;"
      embedded
      renderer="colorManagement: true; alpha: true; antialias: true; precision: high;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      loading-screen="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      <a-assets>
        <video id="vid1" src="https://cdn.jsdelivr.net/gh/OsyaLdn/ar-scan-storage@master/003/003.mp4" preload="auto" loop crossorigin="anonymous" playsinline webkit-playsinline></video>
        <a-asset-item id="model003" src="https://cdn.jsdelivr.net/gh/OsyaLdn/ar-scan-storage@master/001/001.gltf"></a-asset-item>
      </a-assets>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model src="#model003" position="0 0 0" rotation="0 0 0" scale="1 1 1" visible="false"></a-gltf-model>
      </a-entity>

      <a-entity mindar-image-target="targetIndex: 2">
        <a-plane crossorigin="anonymous" width="1.5" height="1" position="0 0 0" rotation="0 0 0" material="transparent: true" video-material="video: #vid1" visible="false"></a-plane>
      </a-entity>

    </a-scene>
  </div>
  <div id="playButton" class="play-button"></div>

  <script>
    // Enhanced cleanup function with memory management
    function performCleanup(fullCleanup = false) {
      const scene = document.querySelector('a-scene');
      const arSystem = scene?.systems['mindar-image-system'];
      
      // Clean up video resources
      const videos = document.querySelectorAll('video');
      videos.forEach(video => {
        if (video && !video.paused) {
          video.pause();
          video.currentTime = 0;
          if (fullCleanup) {
            const src = video.src;
            video.src = '';
            video.load();
            // Reload video source after cleanup
            setTimeout(() => { video.src = src; }, 100);
          }
        }
      });

      // Clean up WebGL context and textures
      if (scene?.renderer) {
        const gl = scene.renderer.getContext();
        
        // Clean up WebGL textures
        const textures = scene.renderer.info.memory.textures || [];
        if (Array.isArray(textures)) {
          textures.forEach(texture => {
            if (texture && texture.dispose) {
              texture.dispose();
            }
          });
        }

        // Clean up WebGL buffers
        if (gl) {
          const numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          for (let unit = 0; unit < numTextureUnits; unit++) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
          }
          
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        if (window.gc) {
          try {
            window.gc();
          } catch (e) {
            console.warn('GC not available');
          }
        }
      }

      // Clean up AR system if needed
      if (fullCleanup && arSystem) {
        try {
          arSystem.stop();
          setTimeout(() => {
            arSystem.start();
          }, 1000);
        } catch (e) {
          console.warn('AR system cleanup error:', e);
        }
      }

      return Promise.resolve();
    }

    // Optimization system
    const AROptimizer = {
      lastCleanup: Date.now(),
      errorCount: 0,
      isProcessing: false,
      
      initialize() {
        this.setupAutoCleanup();
        this.setupErrorHandling();
        this.setupMemoryMonitoring();
      },

      setupAutoCleanup() {
        // Light cleanup every 2 minutes
        setInterval(() => {
          if (!document.hidden && !this.isProcessing) {
            this.isProcessing = true;
            performCleanup(false)
              .finally(() => {
                this.isProcessing = false;
              });
          }
        }, 120000);

        // Full cleanup every 10 minutes
        setInterval(() => {
          if (!document.hidden && !this.isProcessing) {
            this.isProcessing = true;
            performCleanup(true)
              .finally(() => {
                this.isProcessing = false;
              });
          }
        }, 600000);
      },

      setupErrorHandling() {
        const scene = document.querySelector('a-scene');
        if (!scene) return;

        scene.addEventListener('arError', async () => {
          this.errorCount++;
          
          if (this.errorCount > 3) {
            await performCleanup(true);
            this.errorCount = 0;
          } else {
            await performCleanup(false);
          }

          setTimeout(() => {
            this.errorCount = Math.max(0, this.errorCount - 1);
          }, 300000);
        });
      },

      setupMemoryMonitoring() {
        if ('memory' in performance) {
          setInterval(() => {
            const { usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
            if (usedJSHeapSize > jsHeapSizeLimit * 0.8) {
              if (!this.isProcessing) {
                this.isProcessing = true;
                performCleanup(true)
                  .finally(() => {
                    this.isProcessing = false;
                  });
              }
            }
          }, 30000);
        }
      }
    };

    // Register video material component
    AFRAME.registerComponent('video-material', {
      schema: {
        video: { type: 'selector' }
      },

      init: function () {
        const mesh = this.el.getObject3D('mesh');
        const video = this.data.video;

        const vertexShader = `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        const fragmentShader = `
          varying vec2 vUv;
          uniform sampler2D videoTexture;
          
          void main() {
            vec4 color = texture2D(videoTexture, vUv);
            float dx = min(vUv.x, 1.0 - vUv.x);
            float dy = min(vUv.y, 1.0 - vUv.y);
            float edgeDistance = min(dx, dy);
            float fadeWidth = 0.15;
            float opacity = smoothstep(0.0, fadeWidth, edgeDistance);
            float globalOpacity = 0.8;
            gl_FragColor = vec4(color.rgb, color.a * opacity * globalOpacity);
          }
        `;

        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;

        const material = new THREE.ShaderMaterial({
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          uniforms: {
            videoTexture: { value: videoTexture }
          },
          transparent: true,
          alphaTest: 0.01
        });

        mesh.material = material;

        // Enhanced cleanup on component removal
        this.el.addEventListener('componentremoved', (evt) => {
          if (evt.detail.name === 'video-material') {
            if (material.uniforms.videoTexture.value) {
              material.uniforms.videoTexture.value.dispose();
            }
            material.dispose();
          }
        });
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      const loadingProgress = document.getElementById('loading-progress');
      const loadingScreen = document.getElementById('loading-screen');
      const arScene = document.getElementById('ar-scene');
      const scene = document.querySelector('a-scene');
      
      // Initialize scene settings
      loadingScreen.style.display = 'flex';
      loadingProgress.style.display = 'block';
      scene.renderer.setClearColor(0x000000, 0);
      scene.object3D.background = null;

      const targets = [
        // Existing video targets
        {
          video: document.getElementById('vid1'),
          entity: document.querySelector(`a-entity[mindar-image-target="targetIndex: 2"]`),
          plane: document.querySelector(`a-entity[mindar-image-target="targetIndex: 2"] a-plane`),
          type: 'video',
          loaded: false
        },
        // Add GLTF model targets
        {
          model: document.querySelector(`a-entity[mindar-image-target="targetIndex: 0"] a-gltf-model`),
          entity: document.querySelector(`a-entity[mindar-image-target="targetIndex: 0"]`),
          type: 'model',
          loaded: false
        },
        // Add more targets as needed
      ];

      let currentTarget = null;

      // Initialize AR Optimizer
      AROptimizer.initialize();

      // Camera initialization with enhanced error handling
      setTimeout(() => {
        loadingProgress.textContent = 'Starting camera...';
        
        navigator.mediaDevices.getUserMedia({ 
          video: {
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        })
        .then(function(stream) {
          stream.getTracks().forEach(track => track.stop());
          
          scene.addEventListener('arReady', function() {
            loadingScreen.style.display = 'none';
            loadingProgress.style.display = 'none';
            arScene.classList.add('ready');
          });

          function pauseAllVideosExcept(activeVideo) {
            videos.forEach(video => {
              if (video && video !== activeVideo) {
                video.pause();
                video.currentTime = 0;
              }
            });
          }

          const playButton = document.getElementById('playButton');

          // Enhanced play button handler with error recovery
          playButton.addEventListener('click', () => {
            if (currentTarget && currentTarget.video) {
              const startPlayback = async () => {
                currentTarget.plane.setAttribute('visible', true);
                playButton.style.display = 'none';
                try {
                  await currentTarget.video.play();
                } catch (err) {
                  console.warn('Playback failed, retrying:', err);
                  setTimeout(async () => {
                    try {
                      await currentTarget.video.play();
                    } catch (error) {
                      console.error('Retry failed:', error);
                      playButton.style.display = 'flex';
                      currentTarget.plane.setAttribute('visible', false);
                    }
                  }, 100);
                }
              };
              startPlayback();
            }
          });

          targets.forEach(target => {
            if (target.type === 'video') {
              if (!target.video) return;

              target.entity.addEventListener('targetFound', () => {
                if (currentTarget && currentTarget !== target) {
                  currentTarget.video.pause();
                  currentTarget.video.currentTime = 0;
                  currentTarget.plane.setAttribute('visible', false);
                }
                
                currentTarget = target;
                target.video.currentTime = 0;
                pauseAllVideosExcept(target.video);
                target.plane.setAttribute('visible', false);
                playButton.style.display = 'flex';
              });

              target.entity.addEventListener('targetLost', () => {
                if (currentTarget === target) {
                  target.video.pause();
                  target.video.currentTime = 0;
                  playButton.style.display = 'none';
                  target.plane.setAttribute('visible', false);
                  currentTarget = null;
                }
              });

              // Enhanced video event handlers
              target.video.addEventListener('play', () => {
                pauseAllVideosExcept(target.video);
              });

              target.video.addEventListener('ended', () => {
                if (target.video.loop) {
                  target.video.currentTime = 0;
                  target.video.play().catch(() => {
                    playButton.style.display = 'flex';
                  });
                }
              });

              target.video.addEventListener('error', () => {
                console.warn('Video error, attempting recovery');
                if (currentTarget === target) {
                  playButton.style.display = 'none';
                  target.plane.setAttribute('visible', false);
                }
                const currentSrc = target.video.src;
                target.video.src = '';
                target.video.load();
                target.video.src = currentSrc;
              });

              target.video.muted = false; 
            } else if (target.type === 'model') {
              target.entity.addEventListener('targetFound', () => {
                // Show the GLTF model when target is found
                target.model.setAttribute('visible', true);
              });

              target.entity.addEventListener('targetLost', () => {
                // Hide the GLTF model when target is lost
                target.model.setAttribute('visible', false);
              });
            }
          });
        })
        .catch(function(err) {
          console.error('Camera initialization error:', err);
          loadingProgress.textContent = 'Camera permission denied';
        });
      }, 2000);
    });

    // Enhanced visibility change handling
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        performCleanup(true);
      }
    });

    // Additional cleanup handlers
    window.addEventListener('beforeunload', () => performCleanup(true));
    window.addEventListener('pagehide', () => performCleanup(true));
  </script>
</body>
</html>